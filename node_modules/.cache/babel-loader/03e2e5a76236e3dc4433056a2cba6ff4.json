{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.parseActions = parseActions;\nexports.default = undoable;\nexports.distinctState = distinctState;\nexports.includeAction = includeAction;\nexports.ifAction = ifAction;\nexports.excludeAction = excludeAction;\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // debug output\n\n\nvar __DEBUG__ = undefined;\n\nfunction debug() {\n  if (__DEBUG__) {\n    var _console;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (!console.group) {\n      args.unshift('%credux-undo', 'font-style: italic');\n    }\n\n    (_console = console).log.apply(_console, args);\n  }\n}\n\nfunction debugStart(action, state) {\n  if (__DEBUG__) {\n    var args = ['action', action.type];\n\n    if (console.group) {\n      var _console2;\n\n      args.unshift('%credux-undo', 'font-style: italic');\n\n      (_console2 = console).groupCollapsed.apply(_console2, args);\n\n      console.log('received', {\n        state: state,\n        action: action\n      });\n    } else {\n      debug.apply(undefined, args);\n    }\n  }\n}\n\nfunction debugEnd() {\n  if (__DEBUG__) {\n    return console.groupEnd && console.groupEnd();\n  }\n} // /debug output\n// action types\n\n\nvar ActionTypes = exports.ActionTypes = {\n  UNDO: '@@redux-undo/UNDO',\n  REDO: '@@redux-undo/REDO',\n  JUMP_TO_FUTURE: '@@redux-undo/JUMP_TO_FUTURE',\n  JUMP_TO_PAST: '@@redux-undo/JUMP_TO_PAST'\n}; // /action types\n// action creators to change the state\n\nvar ActionCreators = exports.ActionCreators = {\n  undo: function undo() {\n    return {\n      type: ActionTypes.UNDO\n    };\n  },\n  redo: function redo() {\n    return {\n      type: ActionTypes.REDO\n    };\n  },\n  jumpToFuture: function jumpToFuture(index) {\n    return {\n      type: ActionTypes.JUMP_TO_FUTURE,\n      index: index\n    };\n  },\n  jumpToPast: function jumpToPast(index) {\n    return {\n      type: ActionTypes.JUMP_TO_PAST,\n      index: index\n    };\n  }\n}; // /action creators\n// length: get length of history\n\nfunction length(history) {\n  var past = history.past;\n  var future = history.future;\n  return past.length + 1 + future.length;\n} // /length\n// insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit) {\n  debug('insert', {\n    state: state,\n    history: history,\n    free: limit - length(history)\n  });\n  var past = history.past;\n  var present = history.present;\n  var historyOverflow = limit && length(history) >= limit;\n\n  if (present === undefined) {\n    // init history\n    return {\n      past: [],\n      present: state,\n      future: []\n    };\n  }\n\n  return {\n    past: [].concat(_toConsumableArray(past.slice(historyOverflow ? 1 : 0)), [present]),\n    present: state,\n    future: []\n  };\n} // /insert\n// undo: go back to the previous point in history\n\n\nfunction undo(history) {\n  debug('undo', {\n    history: history\n  });\n  var past = history.past;\n  var present = history.present;\n  var future = history.future;\n  if (past.length <= 0) return history;\n  return {\n    past: past.slice(0, past.length - 1),\n    // remove last element from past\n    present: past[past.length - 1],\n    // set element as new present\n    future: [present].concat(_toConsumableArray(future))\n  };\n} // /undo\n// redo: go to the next point in history\n\n\nfunction redo(history) {\n  debug('redo', {\n    history: history\n  });\n  var past = history.past;\n  var present = history.present;\n  var future = history.future;\n  if (future.length <= 0) return history;\n  return {\n    future: future.slice(1, future.length),\n    // remove element from future\n    present: future[0],\n    // set element as new present\n    past: [].concat(_toConsumableArray(past), [present // old present state is in the past now\n    ])\n  };\n} // /redo\n// jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index === 0) return redo(history);\n  var past = history.past;\n  var present = history.present;\n  var future = history.future;\n  return {\n    future: future.slice(index + 1),\n    present: future[index],\n    past: past.concat([present]).concat(future.slice(0, index))\n  };\n} // /jumpToFuture\n// jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index === history.past.length - 1) return undo(history);\n  var past = history.past;\n  var present = history.present;\n  var future = history.future;\n  return {\n    future: past.slice(index + 1).concat([present]).concat(future),\n    present: past[index],\n    past: past.slice(0, index)\n  };\n} // /jumpToPast\n// wrapState: for backwards compatibility to 0.4\n\n\nfunction wrapState(state) {\n  return _extends({}, state, {\n    history: state\n  });\n} // /wrapState\n// updateState\n\n\nfunction updateState(state, history) {\n  return wrapState(_extends({}, state, history));\n} // /updateState\n// createHistory\n\n\nfunction createHistory(state) {\n  return {\n    past: [],\n    present: state,\n    future: []\n  };\n} // /createHistory\n// parseActions\n\n\nfunction parseActions(rawActions) {\n  var defaultValue = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n  if (Array.isArray(rawActions)) {\n    return rawActions;\n  } else if (typeof rawActions === 'string') {\n    return [rawActions];\n  }\n\n  return defaultValue;\n} // /parseActions\n// redux-undo higher order reducer\n\n\nfunction undoable(reducer) {\n  var rawConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n  __DEBUG__ = rawConfig.debug;\n  var config = {\n    initialState: rawConfig.initialState,\n    initTypes: parseActions(rawConfig.initTypes, ['@@redux/INIT', '@@INIT']),\n    limit: rawConfig.limit,\n    filter: rawConfig.filter || function () {\n      return true;\n    },\n    undoType: rawConfig.undoType || ActionTypes.UNDO,\n    redoType: rawConfig.redoType || ActionTypes.REDO,\n    jumpToPastType: rawConfig.jumpToPastType || ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: rawConfig.jumpToFutureType || ActionTypes.JUMP_TO_FUTURE\n  };\n  config.history = rawConfig.initialHistory || createHistory(config.initialState);\n\n  if (config.initTypes.length === 0) {\n    console.warn('redux-undo: supply at least one action type in initTypes to ensure initial state');\n  }\n\n  return function (state, action) {\n    debugStart(action, state);\n    var res = undefined;\n\n    switch (action.type) {\n      case config.undoType:\n        res = undo(state);\n        debug('after undo', res);\n        debugEnd();\n        return res ? updateState(state, res) : state;\n\n      case config.redoType:\n        res = redo(state);\n        debug('after redo', res);\n        debugEnd();\n        return res ? updateState(state, res) : state;\n\n      case config.jumpToPastType:\n        res = jumpToPast(state, action.index);\n        debug('after jumpToPast', res);\n        debugEnd();\n        return res ? updateState(state, res) : state;\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(state, action.index);\n        debug('after jumpToFuture', res);\n        debugEnd();\n        return res ? updateState(state, res) : state;\n\n      default:\n        res = reducer(state && state.present, action);\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug('reset history due to init action');\n          debugEnd();\n          return wrapState(_extends({}, state, createHistory(res)));\n        }\n\n        if (config.filter && typeof config.filter === 'function') {\n          if (!config.filter(action, res, state && state.present)) {\n            debug('filter prevented action, not storing it');\n            debugEnd();\n            return wrapState(_extends({}, state, {\n              present: res\n            }));\n          }\n        }\n\n        var history = state && state.present !== undefined ? state : config.history;\n        var updatedHistory = insert(history, res, config.limit);\n        debug('after insert', {\n          history: updatedHistory,\n          free: config.limit - length(updatedHistory)\n        });\n        debugEnd();\n        return wrapState(_extends({}, state, updatedHistory));\n    }\n  };\n} // /redux-undo\n// distinctState helper\n\n\nfunction distinctState() {\n  return function (action, currentState, previousState) {\n    return currentState !== previousState;\n  };\n} // /distinctState\n// includeAction helper\n\n\nfunction includeAction(rawActions) {\n  var actions = parseActions(rawActions);\n  return function (action) {\n    return actions.indexOf(action.type) >= 0;\n  };\n} // /includeAction\n// deprecated ifAction helper\n\n\nfunction ifAction(rawActions) {\n  console.error('Deprecation Warning: Please change `ifAction` to `includeAction`');\n  return includeAction(rawActions);\n} // /ifAction\n// excludeAction helper\n\n\nfunction excludeAction() {\n  var rawActions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n  var actions = parseActions(rawActions);\n  return function (action) {\n    return actions.indexOf(action.type) < 0;\n  };\n} // /excludeAction","map":null,"metadata":{},"sourceType":"script"}